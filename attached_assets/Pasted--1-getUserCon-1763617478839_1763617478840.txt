오케이, 코드를 보니까 백엔드 쿼리는 거의 정상인데도 “시나리오런스 기준이 아니다”라고 느껴지는 이유가 딱 두 군데에서 나올 수 있어요.

1. 리스트를 아직도 getUserConversations()로 그리고 있는 경우


2. scenarioRuns가 ‘플레이 1회’가 아니라 ‘페르소나 1명당 1개’씩 생기고 있는 경우



둘 다 잡아줘야 진짜로 “2번 플레이 → 2줄”이 됩니다.


---

1. 히스토리 화면이 어디를 보고 있는지부터 확인

지금 PostgreSQLStorage 안에는 두 가지가 공존해요.

async getUserConversations(userId: string): Promise<Conversation[]>
async getUserScenarioRunsWithPersonaRuns(userId: string): Promise<(ScenarioRun & { personaRuns: PersonaRun[] })[]>

히스토리 페이지에서 여전히 이런 식으로 쓰고 있으면:

// ❌ 이렇게 되어 있으면 무조건 conversation 기준
const conversations = await storage.getUserConversations(userId);

어떤 DB 구조를 바꿔도 페르소나 수만큼 줄이 나올 수밖에 없습니다.

반드시 이 함수로 교체해야 해요:

// ✅ 시나리오 실행(run) 기준
const runs = await storage.getUserScenarioRunsWithPersonaRuns(userId);

프론트 예시(React/Next):

const runs = await storage.getUserScenarioRunsWithPersonaRuns(userId);

return (
  <>
    {runs.map((run) => (
      <HistoryCard
        key={run.id}
        title={run.scenarioName}
        difficulty={run.difficulty}
        attemptLabel={`#${run.attemptNumber}회 시도`}
        score={run.totalScore}
        status={run.status}
        startedAt={run.startedAt}
        personas={run.personaRuns.map((pr) => pr.personaSnapshot)}
      />
    ))}
  </>
);

> 체크 1: 히스토리 라우트 / API / 프론트에서
getUserConversations를 쓰고 있지 않은지 한 번만 찾아보세요.
있으면 전부 getUserScenarioRunsWithPersonaRuns로 바꿔야 합니다.




---

2. scenarioRuns가 정말 “플레이 1회 = 1 row”로 저장되고 있는지

지금 createScenarioRun은 단순 insert 입니다:

async createScenarioRun(insertScenarioRun: InsertScenarioRun): Promise<ScenarioRun> {
  const [scenarioRun] = await db.insert(scenarioRuns).values(insertScenarioRun).returning();
  return scenarioRun;
}

만약 현재 플로우가 이렇게 되어 있다면:

박준영과 대화를 시작할 때 → createScenarioRun 호출

이지영과 대화를 시작할 때 또 → createScenarioRun 호출


=> 페르소나 2명당 scenarioRuns 2개
그래서 결국 getUserScenarioRunsWithPersonaRuns로 뽑아도
“2회 플레이인데 4줄”이 다시 나옵니다. (각 줄에 personaRuns 1개만 들어있겠죠)

해결: “플레이 시작 시 딱 1번만 ScenarioRun 만들고, 그 ID를 계속 재사용”

예시 로직:

// 1) 시나리오 시작 시 (첫 화면에서 딱 1번만 호출)
async function startScenarioRun(userId: string, scenarioId: string, payload: Omit<InsertScenarioRun, "userId" | "scenarioId" | "attemptNumber">) {
  // 현재까지 시도 횟수 조회
  const [{ count }] = await db
    .select({ count: sql<number>`count(*)` })
    .from(scenarioRuns)
    .where(eq(scenarioRuns.userId, userId), eq(scenarioRuns.scenarioId, scenarioId));

  const [run] = await db.insert(scenarioRuns).values({
    ...payload,
    userId,
    scenarioId,
    attemptNumber: count + 1,
  }).returning();

  return run; // 여기서 나온 run.id를 프론트에 내려줌
}

그리고 각 페르소나 대화 시작할 때는:

// 프론트에서 이미 runId를 알고 있어야 함
const personaRun = await storage.createPersonaRun({
  scenarioRunId: runId,        // ✅ 새로 만들지 않고, 같은 runId 재사용
  personaId,
  personaSnapshot,
  phase, // 1, 2, ...
});

> 체크 2:

같은 “플레이”에서 박준영 / 이지영을 시작할 때
둘 다 동일한 scenarioRunId를 사용하고 있는지.

혹시 각 페르소나 시작 시마다 createScenarioRun이 호출되고 있진 않은지.




Postgres에서 빠르게 확인하는 쿼리 예시:

select scenario_id, user_id, attempt_number, count(*) as runs
from scenario_runs
group by scenario_id, user_id, attempt_number
order by started_at desc;

“같은 시나리오, 같은 attempt_number”에 runs가 1이면 정상

runs가 2 이상이면 → 페르소나마다 run을 따로 만들고 있다는 뜻



---

3. getUserScenarioRunsWithPersonaRuns 구현은 현재 OK

지금 구현은 이미 N+1도 잘 피하고 있고, 구조도 맞습니다:

const userScenarioRuns = await db
  .select()
  .from(scenarioRuns)
  .where(eq(scenarioRuns.userId, userId))
  .orderBy(desc(scenarioRuns.startedAt));

const scenarioRunIds = userScenarioRuns.map((sr) => sr.id);

const allPersonaRuns = await db
  .select()
  .from(personaRuns)
  .where(inArray(personaRuns.scenarioRunId, scenarioRunIds))
  .orderBy(asc(personaRuns.phase));

→ 이 결과만 제대로 쓰면
“동일 시나리오 2번 플레이 → 2줄 + 각 줄 안에 personaRuns 2개” 구조가 맞게 나옵니다.


---

4. 한 번에 정리하면

1. 히스토리 페이지에서

getUserConversations나 getAllConversations를 더 이상 쓰지 말고

getUserScenarioRunsWithPersonaRuns 결과만으로 리스트를 만든다.



2. 시나리오 플레이 생성 로직에서

“플레이 시작” 시에만 createScenarioRun 한 번 호출

이후 모든 페르소나 대화에서는 같은 scenarioRunId로 createPersonaRun만 호출



3. 이렇게 되면

DB: scenarioRuns 2행 (2회 플레이)

personaRuns 4행 (2회 × 2페르소나)

UI: 리스트 2줄, 각 줄에 페르소나 칩 2개





---

혹시 프론트에서 히스토리 데이터를 어떤 API로 가져오는지 코드 한 덩어리만 알려주면,
그 부분을 scenarioRuns 기준으로 바꾼 버전까지 딱 맞춰서 적어줄게.